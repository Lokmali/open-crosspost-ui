import { CrosspostClient } from "@crosspost/sdk";
import { generateNonce, NearAuthData } from "near-sign-verify";
import { OPEN_CROSSPOST_PROXY_API } from "../config";
import {
  AUTHORIZATION_EVENTS,
  authorizationEvents,
} from "./authorization-events";
import { toast } from "../hooks/use-toast";

let clientInstance: CrosspostClient | null = null;

/**
 * Gets or creates a CrosspostClient instance
 * @returns The CrosspostClient instance
 */
export function getClient(): CrosspostClient {
  if (!clientInstance) {
    clientInstance = new CrosspostClient({
      baseUrl: OPEN_CROSSPOST_PROXY_API,
    });
  }
  return clientInstance;
}

/**
 * Creates the data payload needed for the authorization process.
 * This involves signing a message with the user's NEAR wallet.
 * @param wallet - NEAR wallet instance
 * @param accountId - NEAR account ID
 * @returns Promise resolving to the authorization payload
 */
export async function createAuthorizationPayload(
  wallet: any,
  accountId: string,
): Promise<NearAuthData> {
  if (!wallet || !accountId) {
    throw new Error("Wallet and account ID are required");
  }

  const message = `I authorize crosspost to post on my behalf to connected social platforms using my NEAR account: ${accountId}`;
  const nonce = generateNonce();
  const recipient = "crosspost.near";
  const callbackUrl = location.href;

  const signedMessage = await wallet.signMessage({
    message,
    nonce: Buffer.from(nonce),
    recipient,
    callbackUrl,
  });

  return {
    message,
    nonce,
    recipient,
    callback_url: callbackUrl,
    signature: signedMessage.signature,
    account_id: signedMessage.accountId,
    public_key: signedMessage.publicKey,
  };
}

/**
 * Authorizes the app by verifying the payload with the backend,
 * persisting the authorization state, and notifying listeners.
 * @param authorizationPayload - The payload generated by createAuthorizationPayload
 * @returns Promise resolving to true if authorization was successful, false otherwise.
 * @throws Error if the authorization process fails unexpectedly.
 */
export async function authorize(
  authorizationPayload: NearAuthData,
): Promise<boolean> {
  toast({
    title: "Authorizing...",
    description: "that your wallet can call the server",
    variant: "default",
  });

  try {
    const client = getClient();
    // Note: Setting authentication here might be moved to the authentication-service later
    client.setAuthentication(authorizationPayload);

    // Call the SDK method to verify with the backend
    const response = await client.auth.authorizeNearAccount();

    // Check if the response was successful
    if (response.success) {
      // Persist authorization state
      localStorage.setItem("crosspost:authorized", "true");
      // Emit event
      authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZED);
    } else {
      const errorMessage = response.errors?.length
        ? response.errors[0].message
        : "Authorization failed";
      throw new Error(errorMessage);
    }

    return true;
  } catch (error) {
    console.error("Authorization error:", error);
    localStorage.removeItem("crosspost:authorized");
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);
    throw error; // Re-throw for handling in UI
  }
}

/**
 * Unauthorizes the app by removing persisted state, notifying listeners,
 * and potentially informing the backend.
 * @returns Promise resolving when unauthorization is complete.
 */
export async function unauthorize(): Promise<void> {
  toast({
    title: "Revoking Authorization...",
    description: "Removing your authorization from the server",
    variant: "default",
  });

  try {
    const client = getClient();
    const response = await client.auth.unauthorizeNear();

    if (!response.success) {
      const errorMessage = response.errors?.length
        ? response.errors[0].message
        : "Unknown error occurred";
      throw new Error(errorMessage);
    }

    // Remove persisted state regardless of backend call success
    localStorage.removeItem("crosspost:authorized");
    // Emit event
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);

    toast({
      title: "Authorization Revoked",
      description: "Successfully removed your authorization",
      variant: "success",
    });
  } catch (error) {
    toast({
      title: "Revocation Failed",
      description:
        error instanceof Error
          ? error.message
          : "Failed to revoke authorization",
      variant: "destructive",
    });
    console.error("Unauthorization error:", error);
    // Even if backend call fails, ensure local state is cleared
    localStorage.removeItem("crosspost:authorized");
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);
  }
}
