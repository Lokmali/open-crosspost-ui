import { CrosspostClient } from "@crosspost/sdk";
import { generateNonce, NearAuthData } from "near-sign-verify";
import { OPEN_CROSSPOST_PROXY_API } from "../config";
import {
  AUTHORIZATION_EVENTS,
  authorizationEvents,
} from "./authorization-events";

let clientInstance: CrosspostClient | null = null;

/**
 * Gets or creates a CrosspostClient instance
 * @returns The CrosspostClient instance
 */
export function getClient(): CrosspostClient {
  if (!clientInstance) {
    clientInstance = new CrosspostClient({
      baseUrl: OPEN_CROSSPOST_PROXY_API,
    });
  }
  return clientInstance;
}

/**
 * Creates the data payload needed for the authorization process.
 * This involves signing a message with the user's NEAR wallet.
 * @param wallet - NEAR wallet instance
 * @param accountId - NEAR account ID
 * @returns Promise resolving to the authorization payload
 */
export async function createAuthorizationPayload(
  wallet: any,
  accountId: string,
): Promise<NearAuthData> {
  if (!wallet || !accountId) {
    throw new Error("Wallet and account ID are required");
  }

  const message = `I authorize crosspost to post on my behalf to connected social platforms using my NEAR account: ${accountId}`;
  const nonce = generateNonce();
  const recipient = "crosspost.near";
  const callbackUrl = location.href;

  const signedMessage = await wallet.signMessage({
    message,
    nonce: Buffer.from(nonce),
    recipient,
    callbackUrl,
  });

  return {
    message,
    nonce,
    recipient,
    callback_url: callbackUrl,
    signature: signedMessage.signature,
    account_id: signedMessage.accountId,
    public_key: signedMessage.publicKey,
  };
}

/**
 * Authorizes the app by verifying the payload with the backend,
 * persisting the authorization state, and notifying listeners.
 * @param authorizationPayload - The payload generated by createAuthorizationPayload
 * @returns Promise resolving to true if authorization was successful, false otherwise.
 * @throws Error if the authorization process fails unexpectedly.
 */
export async function authorize(
  authorizationPayload: NearAuthData,
): Promise<boolean> {
  try {
    const client = getClient();
    // Note: Setting authentication here might be moved to the authentication-service later
    client.setAuthentication(authorizationPayload);

    // Call the SDK method to verify with the backend
    const response = await client.auth.authorizeNearAccount();

    // Persist authorization state
    localStorage.setItem("crosspost:authorized", "true");
    // Emit event
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZED);
    
    return true;
  } catch (error) {
    console.error("Authorization error:", error);
    localStorage.removeItem("crosspost:authorized");
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);
    throw error; // Re-throw for handling in UI
  }
}

/**
 * Unauthorizes the app by removing persisted state, notifying listeners,
 * and potentially informing the backend.
 * @returns Promise resolving when unauthorization is complete.
 */
// Add new unauthorize function
export async function unauthorize(): Promise<void> {
  try {
    const client = getClient();
    // TODO: Check if client.unauthorizeNearAccount exists and call it
    // await client.unauthorizeNearAccount(); // Assuming this method exists

    // Remove persisted state regardless of backend call success
    localStorage.removeItem("crosspost:authorized");
    // Emit event
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);

    console.log("App unauthorized.");
  } catch (error) {
    console.error("Unauthorization error:", error);
    // Even if backend call fails, ensure local state is cleared
    localStorage.removeItem("crosspost:authorized");
    authorizationEvents.emit(AUTHORIZATION_EVENTS.AUTHORIZATION_REVOKED);
    // Decide if this error should be surfaced to the user
  }
}
